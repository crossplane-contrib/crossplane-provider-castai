/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AggressiveModeConfigInitParameters struct {

	// path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
	// Rebalance workloads that use local-path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
	IgnoreLocalPersistentVolumes *bool `json:"ignoreLocalPersistentVolumes,omitempty" tf:"ignore_local_persistent_volumes,omitempty"`

	// (Boolean) Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
	// Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
	IgnoreProblemJobPods *bool `json:"ignoreProblemJobPods,omitempty" tf:"ignore_problem_job_pods,omitempty"`

	// (Boolean) Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
	// Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
	IgnoreProblemPodsWithoutController *bool `json:"ignoreProblemPodsWithoutController,omitempty" tf:"ignore_problem_pods_without_controller,omitempty"`

	// (Boolean) Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
	// Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
	IgnoreProblemRemovalDisabledPods *bool `json:"ignoreProblemRemovalDisabledPods,omitempty" tf:"ignore_problem_removal_disabled_pods,omitempty"`
}

type AggressiveModeConfigObservation struct {

	// path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
	// Rebalance workloads that use local-path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
	IgnoreLocalPersistentVolumes *bool `json:"ignoreLocalPersistentVolumes,omitempty" tf:"ignore_local_persistent_volumes,omitempty"`

	// (Boolean) Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
	// Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
	IgnoreProblemJobPods *bool `json:"ignoreProblemJobPods,omitempty" tf:"ignore_problem_job_pods,omitempty"`

	// (Boolean) Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
	// Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
	IgnoreProblemPodsWithoutController *bool `json:"ignoreProblemPodsWithoutController,omitempty" tf:"ignore_problem_pods_without_controller,omitempty"`

	// (Boolean) Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
	// Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
	IgnoreProblemRemovalDisabledPods *bool `json:"ignoreProblemRemovalDisabledPods,omitempty" tf:"ignore_problem_removal_disabled_pods,omitempty"`
}

type AggressiveModeConfigParameters struct {

	// path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
	// Rebalance workloads that use local-path Persistent Volumes. THIS WILL RESULT IN DATA LOSS.
	// +kubebuilder:validation:Optional
	IgnoreLocalPersistentVolumes *bool `json:"ignoreLocalPersistentVolumes" tf:"ignore_local_persistent_volumes,omitempty"`

	// (Boolean) Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
	// Pods spawned by Jobs or CronJobs will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, pods spawned by Jobs or CronJobs will be terminated if the Rebalancer picks a node that runs them. As such, they are likely to lose their progress.
	// +kubebuilder:validation:Optional
	IgnoreProblemJobPods *bool `json:"ignoreProblemJobPods" tf:"ignore_problem_job_pods,omitempty"`

	// (Boolean) Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
	// Pods that don't have a controller (bare pods) will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods might not restart, since they have no controller to do it.
	// +kubebuilder:validation:Optional
	IgnoreProblemPodsWithoutController *bool `json:"ignoreProblemPodsWithoutController" tf:"ignore_problem_pods_without_controller,omitempty"`

	// (Boolean) Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
	// Pods that are marked with "removal disabled" will not prevent the Rebalancer from deleting a node on which they run. WARNING: When true, such pods will be evicted and disrupted.
	// +kubebuilder:validation:Optional
	IgnoreProblemRemovalDisabledPods *bool `json:"ignoreProblemRemovalDisabledPods" tf:"ignore_problem_removal_disabled_pods,omitempty"`
}

type ExecutionConditionsInitParameters struct {

	// (Number) The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	// The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	AchievedSavingsPercentage *float64 `json:"achievedSavingsPercentage,omitempty" tf:"achieved_savings_percentage,omitempty"`

	// (Boolean) Enables or disables the execution conditions.
	// Enables or disables the execution conditions.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ExecutionConditionsObservation struct {

	// (Number) The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	// The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	AchievedSavingsPercentage *float64 `json:"achievedSavingsPercentage,omitempty" tf:"achieved_savings_percentage,omitempty"`

	// (Boolean) Enables or disables the execution conditions.
	// Enables or disables the execution conditions.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ExecutionConditionsParameters struct {

	// (Number) The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	// The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	// +kubebuilder:validation:Optional
	AchievedSavingsPercentage *float64 `json:"achievedSavingsPercentage,omitempty" tf:"achieved_savings_percentage,omitempty"`

	// (Boolean) Enables or disables the execution conditions.
	// Enables or disables the execution conditions.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`
}

type LaunchConfigurationInitParameters struct {

	// disabled annotation) as not-problematic.
	// When enabled rebalancing will also consider problematic pods (pods without controller, job pods, pods with removal-disabled annotation) as not-problematic.
	AggressiveMode *bool `json:"aggressiveMode,omitempty" tf:"aggressive_mode,omitempty"`

	// (Block List, Max: 1) Advanced configuration for aggressive rebalancing mode. (see below for nested schema)
	// Advanced configuration for aggressive rebalancing mode.
	AggressiveModeConfig []AggressiveModeConfigInitParameters `json:"aggressiveModeConfig,omitempty" tf:"aggressive_mode_config,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	ExecutionConditions []ExecutionConditionsInitParameters `json:"executionConditions,omitempty" tf:"execution_conditions,omitempty"`

	// failed annotation instead of forcefully drained.
	// Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
	KeepDrainTimeoutNodes *bool `json:"keepDrainTimeoutNodes,omitempty" tf:"keep_drain_timeout_nodes,omitempty"`

	// (Number) Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	// Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	NodeTTLSeconds *float64 `json:"nodeTtlSeconds,omitempty" tf:"node_ttl_seconds,omitempty"`

	// (Number) Maximum number of nodes that will be selected for rebalancing.
	// Maximum number of nodes that will be selected for rebalancing.
	NumTargetedNodes *float64 `json:"numTargetedNodes,omitempty" tf:"num_targeted_nodes,omitempty"`

	// (Number) Minimum number of nodes that should be kept in the cluster after rebalancing.
	// Minimum number of nodes that should be kept in the cluster after rebalancing.
	RebalancingMinNodes *float64 `json:"rebalancingMinNodes,omitempty" tf:"rebalancing_min_nodes,omitempty"`

	// (String) Node selector in JSON format.
	// Node selector in JSON format.
	Selector *string `json:"selector,omitempty" tf:"selector,omitempty"`

	// (String) Defines the algorithm used to select the target nodes for rebalancing.
	// Defines the algorithm used to select the target nodes for rebalancing.
	TargetNodeSelectionAlgorithm *string `json:"targetNodeSelectionAlgorithm,omitempty" tf:"target_node_selection_algorithm,omitempty"`
}

type LaunchConfigurationObservation struct {

	// disabled annotation) as not-problematic.
	// When enabled rebalancing will also consider problematic pods (pods without controller, job pods, pods with removal-disabled annotation) as not-problematic.
	AggressiveMode *bool `json:"aggressiveMode,omitempty" tf:"aggressive_mode,omitempty"`

	// (Block List, Max: 1) Advanced configuration for aggressive rebalancing mode. (see below for nested schema)
	// Advanced configuration for aggressive rebalancing mode.
	AggressiveModeConfig []AggressiveModeConfigObservation `json:"aggressiveModeConfig,omitempty" tf:"aggressive_mode_config,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	ExecutionConditions []ExecutionConditionsObservation `json:"executionConditions,omitempty" tf:"execution_conditions,omitempty"`

	// failed annotation instead of forcefully drained.
	// Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
	KeepDrainTimeoutNodes *bool `json:"keepDrainTimeoutNodes,omitempty" tf:"keep_drain_timeout_nodes,omitempty"`

	// (Number) Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	// Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	NodeTTLSeconds *float64 `json:"nodeTtlSeconds,omitempty" tf:"node_ttl_seconds,omitempty"`

	// (Number) Maximum number of nodes that will be selected for rebalancing.
	// Maximum number of nodes that will be selected for rebalancing.
	NumTargetedNodes *float64 `json:"numTargetedNodes,omitempty" tf:"num_targeted_nodes,omitempty"`

	// (Number) Minimum number of nodes that should be kept in the cluster after rebalancing.
	// Minimum number of nodes that should be kept in the cluster after rebalancing.
	RebalancingMinNodes *float64 `json:"rebalancingMinNodes,omitempty" tf:"rebalancing_min_nodes,omitempty"`

	// (String) Node selector in JSON format.
	// Node selector in JSON format.
	Selector *string `json:"selector,omitempty" tf:"selector,omitempty"`

	// (String) Defines the algorithm used to select the target nodes for rebalancing.
	// Defines the algorithm used to select the target nodes for rebalancing.
	TargetNodeSelectionAlgorithm *string `json:"targetNodeSelectionAlgorithm,omitempty" tf:"target_node_selection_algorithm,omitempty"`
}

type LaunchConfigurationParameters struct {

	// disabled annotation) as not-problematic.
	// When enabled rebalancing will also consider problematic pods (pods without controller, job pods, pods with removal-disabled annotation) as not-problematic.
	// +kubebuilder:validation:Optional
	AggressiveMode *bool `json:"aggressiveMode,omitempty" tf:"aggressive_mode,omitempty"`

	// (Block List, Max: 1) Advanced configuration for aggressive rebalancing mode. (see below for nested schema)
	// Advanced configuration for aggressive rebalancing mode.
	// +kubebuilder:validation:Optional
	AggressiveModeConfig []AggressiveModeConfigParameters `json:"aggressiveModeConfig,omitempty" tf:"aggressive_mode_config,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	ExecutionConditions []ExecutionConditionsParameters `json:"executionConditions,omitempty" tf:"execution_conditions,omitempty"`

	// failed annotation instead of forcefully drained.
	// Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
	// +kubebuilder:validation:Optional
	KeepDrainTimeoutNodes *bool `json:"keepDrainTimeoutNodes,omitempty" tf:"keep_drain_timeout_nodes,omitempty"`

	// (Number) Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	// Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	// +kubebuilder:validation:Optional
	NodeTTLSeconds *float64 `json:"nodeTtlSeconds,omitempty" tf:"node_ttl_seconds,omitempty"`

	// (Number) Maximum number of nodes that will be selected for rebalancing.
	// Maximum number of nodes that will be selected for rebalancing.
	// +kubebuilder:validation:Optional
	NumTargetedNodes *float64 `json:"numTargetedNodes,omitempty" tf:"num_targeted_nodes,omitempty"`

	// (Number) Minimum number of nodes that should be kept in the cluster after rebalancing.
	// Minimum number of nodes that should be kept in the cluster after rebalancing.
	// +kubebuilder:validation:Optional
	RebalancingMinNodes *float64 `json:"rebalancingMinNodes,omitempty" tf:"rebalancing_min_nodes,omitempty"`

	// (String) Node selector in JSON format.
	// Node selector in JSON format.
	// +kubebuilder:validation:Optional
	Selector *string `json:"selector,omitempty" tf:"selector,omitempty"`

	// (String) Defines the algorithm used to select the target nodes for rebalancing.
	// Defines the algorithm used to select the target nodes for rebalancing.
	// +kubebuilder:validation:Optional
	TargetNodeSelectionAlgorithm *string `json:"targetNodeSelectionAlgorithm,omitempty" tf:"target_node_selection_algorithm,omitempty"`
}

type RebalancingScheduleInitParameters struct {

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	LaunchConfiguration []LaunchConfigurationInitParameters `json:"launchConfiguration,omitempty" tf:"launch_configuration,omitempty"`

	// (String) Name of the schedule.
	// Name of the schedule.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	Schedule []RebalancingScheduleScheduleInitParameters `json:"schedule,omitempty" tf:"schedule,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	TriggerConditions []TriggerConditionsInitParameters `json:"triggerConditions,omitempty" tf:"trigger_conditions,omitempty"`
}

type RebalancingScheduleObservation struct {

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	LaunchConfiguration []LaunchConfigurationObservation `json:"launchConfiguration,omitempty" tf:"launch_configuration,omitempty"`

	// (String) Name of the schedule.
	// Name of the schedule.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	Schedule []RebalancingScheduleScheduleObservation `json:"schedule,omitempty" tf:"schedule,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	TriggerConditions []TriggerConditionsObservation `json:"triggerConditions,omitempty" tf:"trigger_conditions,omitempty"`
}

type RebalancingScheduleParameters struct {

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	LaunchConfiguration []LaunchConfigurationParameters `json:"launchConfiguration,omitempty" tf:"launch_configuration,omitempty"`

	// (String) Name of the schedule.
	// Name of the schedule.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Schedule []RebalancingScheduleScheduleParameters `json:"schedule,omitempty" tf:"schedule,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	TriggerConditions []TriggerConditionsParameters `json:"triggerConditions,omitempty" tf:"trigger_conditions,omitempty"`
}

type RebalancingScheduleScheduleInitParameters struct {

	// (String) Cron expression defining when the schedule should trigger.
	// Cron expression defining when the schedule should trigger.
	//
	// The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.
	//
	// Example:
	// ```plaintext
	// CRON_TZ=America/New_York 0 12 * * ?
	// ```
	// In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.
	//
	// To retrieve a list of available timezone values, you can use the following API endpoint:
	//
	// GET https://api.cast.ai/v1/time-zones
	//
	// When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
	Cron *string `json:"cron,omitempty" tf:"cron,omitempty"`
}

type RebalancingScheduleScheduleObservation struct {

	// (String) Cron expression defining when the schedule should trigger.
	// Cron expression defining when the schedule should trigger.
	//
	// The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.
	//
	// Example:
	// ```plaintext
	// CRON_TZ=America/New_York 0 12 * * ?
	// ```
	// In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.
	//
	// To retrieve a list of available timezone values, you can use the following API endpoint:
	//
	// GET https://api.cast.ai/v1/time-zones
	//
	// When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
	Cron *string `json:"cron,omitempty" tf:"cron,omitempty"`
}

type RebalancingScheduleScheduleParameters struct {

	// (String) Cron expression defining when the schedule should trigger.
	// Cron expression defining when the schedule should trigger.
	//
	// The `cron` expression can optionally include the `CRON_TZ` variable at the beginning to specify the timezone in which the schedule should be interpreted.
	//
	// Example:
	// ```plaintext
	// CRON_TZ=America/New_York 0 12 * * ?
	// ```
	// In the example above, the `CRON_TZ` variable is set to "America/New_York" indicating that the cron expression should be interpreted in the Eastern Time (ET) timezone.
	//
	// To retrieve a list of available timezone values, you can use the following API endpoint:
	//
	// GET https://api.cast.ai/v1/time-zones
	//
	// When using the `CRON_TZ` variable, ensure that the specified timezone is valid and supported by checking the list of available timezones from the API endpoint.  If the `CRON_TZ` variable is not specified, the cron expression will be interpreted in the UTC timezone.
	// +kubebuilder:validation:Optional
	Cron *string `json:"cron" tf:"cron,omitempty"`
}

type TriggerConditionsInitParameters struct {

	// (Boolean) If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
	// If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
	IgnoreSavings *bool `json:"ignoreSavings,omitempty" tf:"ignore_savings,omitempty"`

	// (Number) Defines the minimum percentage of savings expected.
	// Defines the minimum percentage of savings expected.
	SavingsPercentage *float64 `json:"savingsPercentage,omitempty" tf:"savings_percentage,omitempty"`
}

type TriggerConditionsObservation struct {

	// (Boolean) If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
	// If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
	IgnoreSavings *bool `json:"ignoreSavings,omitempty" tf:"ignore_savings,omitempty"`

	// (Number) Defines the minimum percentage of savings expected.
	// Defines the minimum percentage of savings expected.
	SavingsPercentage *float64 `json:"savingsPercentage,omitempty" tf:"savings_percentage,omitempty"`
}

type TriggerConditionsParameters struct {

	// (Boolean) If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
	// If true, the savings percentage will be ignored and the rebalancing will be triggered regardless of the savings percentage.
	// +kubebuilder:validation:Optional
	IgnoreSavings *bool `json:"ignoreSavings,omitempty" tf:"ignore_savings,omitempty"`

	// (Number) Defines the minimum percentage of savings expected.
	// Defines the minimum percentage of savings expected.
	// +kubebuilder:validation:Optional
	SavingsPercentage *float64 `json:"savingsPercentage" tf:"savings_percentage,omitempty"`
}

// RebalancingScheduleSpec defines the desired state of RebalancingSchedule
type RebalancingScheduleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RebalancingScheduleParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RebalancingScheduleInitParameters `json:"initProvider,omitempty"`
}

// RebalancingScheduleStatus defines the observed state of RebalancingSchedule.
type RebalancingScheduleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RebalancingScheduleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// RebalancingSchedule is the Schema for the RebalancingSchedules API. CAST AI rebalancing schedule resource to manage rebalancing schedules.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,castai}
type RebalancingSchedule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.launchConfiguration) || (has(self.initProvider) && has(self.initProvider.launchConfiguration))",message="spec.forProvider.launchConfiguration is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.schedule) || (has(self.initProvider) && has(self.initProvider.schedule))",message="spec.forProvider.schedule is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.triggerConditions) || (has(self.initProvider) && has(self.initProvider.triggerConditions))",message="spec.forProvider.triggerConditions is a required parameter"
	Spec   RebalancingScheduleSpec   `json:"spec"`
	Status RebalancingScheduleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RebalancingScheduleList contains a list of RebalancingSchedules
type RebalancingScheduleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RebalancingSchedule `json:"items"`
}

// Repository type metadata.
var (
	RebalancingSchedule_Kind             = "RebalancingSchedule"
	RebalancingSchedule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RebalancingSchedule_Kind}.String()
	RebalancingSchedule_KindAPIVersion   = RebalancingSchedule_Kind + "." + CRDGroupVersion.String()
	RebalancingSchedule_GroupVersionKind = CRDGroupVersion.WithKind(RebalancingSchedule_Kind)
)

func init() {
	SchemeBuilder.Register(&RebalancingSchedule{}, &RebalancingScheduleList{})
}
