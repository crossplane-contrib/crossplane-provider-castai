/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ExecutionConditionsObservation struct {

	// The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	AchievedSavingsPercentage *float64 `json:"achievedSavingsPercentage,omitempty" tf:"achieved_savings_percentage,omitempty"`

	// Enables or disables the execution conditions.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ExecutionConditionsParameters struct {

	// The percentage of the predicted savings that must be achieved in order to fully execute the plan.If the savings are not achieved after creating the new nodes, the plan will fail and delete the created nodes.
	// +kubebuilder:validation:Optional
	AchievedSavingsPercentage *float64 `json:"achievedSavingsPercentage,omitempty" tf:"achieved_savings_percentage,omitempty"`

	// Enables or disables the execution conditions.
	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`
}

type LaunchConfigurationObservation struct {
	ExecutionConditions []ExecutionConditionsObservation `json:"executionConditions,omitempty" tf:"execution_conditions,omitempty"`

	// Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
	KeepDrainTimeoutNodes *bool `json:"keepDrainTimeoutNodes,omitempty" tf:"keep_drain_timeout_nodes,omitempty"`

	// Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	NodeTTLSeconds *float64 `json:"nodeTtlSeconds,omitempty" tf:"node_ttl_seconds,omitempty"`

	// Maximum number of nodes that will be selected for rebalancing.
	NumTargetedNodes *float64 `json:"numTargetedNodes,omitempty" tf:"num_targeted_nodes,omitempty"`

	// Minimum number of nodes that should be kept in the cluster after rebalancing.
	RebalancingMinNodes *float64 `json:"rebalancingMinNodes,omitempty" tf:"rebalancing_min_nodes,omitempty"`

	// Node selector in JSON format.
	Selector *string `json:"selector,omitempty" tf:"selector,omitempty"`
}

type LaunchConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ExecutionConditions []ExecutionConditionsParameters `json:"executionConditions,omitempty" tf:"execution_conditions,omitempty"`

	// Defines whether the nodes that failed to get drained until a predefined timeout, will be kept with a rebalancing.cast.ai/status=drain-failed annotation instead of forcefully drained.
	// +kubebuilder:validation:Optional
	KeepDrainTimeoutNodes *bool `json:"keepDrainTimeoutNodes,omitempty" tf:"keep_drain_timeout_nodes,omitempty"`

	// Specifies amount of time since node creation before the node is allowed to be considered for automated rebalancing.
	// +kubebuilder:validation:Optional
	NodeTTLSeconds *float64 `json:"nodeTtlSeconds,omitempty" tf:"node_ttl_seconds,omitempty"`

	// Maximum number of nodes that will be selected for rebalancing.
	// +kubebuilder:validation:Optional
	NumTargetedNodes *float64 `json:"numTargetedNodes,omitempty" tf:"num_targeted_nodes,omitempty"`

	// Minimum number of nodes that should be kept in the cluster after rebalancing.
	// +kubebuilder:validation:Optional
	RebalancingMinNodes *float64 `json:"rebalancingMinNodes,omitempty" tf:"rebalancing_min_nodes,omitempty"`

	// Node selector in JSON format.
	// +kubebuilder:validation:Optional
	Selector *string `json:"selector,omitempty" tf:"selector,omitempty"`
}

type RebalancingScheduleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	LaunchConfiguration []LaunchConfigurationObservation `json:"launchConfiguration,omitempty" tf:"launch_configuration,omitempty"`

	// Name of the schedule.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Schedule []ScheduleObservation `json:"schedule,omitempty" tf:"schedule,omitempty"`

	TriggerConditions []TriggerConditionsObservation `json:"triggerConditions,omitempty" tf:"trigger_conditions,omitempty"`
}

type RebalancingScheduleParameters struct {

	// +kubebuilder:validation:Optional
	LaunchConfiguration []LaunchConfigurationParameters `json:"launchConfiguration,omitempty" tf:"launch_configuration,omitempty"`

	// Name of the schedule.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Schedule []ScheduleParameters `json:"schedule,omitempty" tf:"schedule,omitempty"`

	// +kubebuilder:validation:Optional
	TriggerConditions []TriggerConditionsParameters `json:"triggerConditions,omitempty" tf:"trigger_conditions,omitempty"`
}

type ScheduleObservation struct {

	// Cron expression defining when the schedule should trigger.
	Cron *string `json:"cron,omitempty" tf:"cron,omitempty"`
}

type ScheduleParameters struct {

	// Cron expression defining when the schedule should trigger.
	// +kubebuilder:validation:Required
	Cron *string `json:"cron" tf:"cron,omitempty"`
}

type TriggerConditionsObservation struct {

	// Defines the minimum percentage of savings expected.
	SavingsPercentage *float64 `json:"savingsPercentage,omitempty" tf:"savings_percentage,omitempty"`
}

type TriggerConditionsParameters struct {

	// Defines the minimum percentage of savings expected.
	// +kubebuilder:validation:Required
	SavingsPercentage *float64 `json:"savingsPercentage" tf:"savings_percentage,omitempty"`
}

// RebalancingScheduleSpec defines the desired state of RebalancingSchedule
type RebalancingScheduleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RebalancingScheduleParameters `json:"forProvider"`
}

// RebalancingScheduleStatus defines the observed state of RebalancingSchedule.
type RebalancingScheduleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RebalancingScheduleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// RebalancingSchedule is the Schema for the RebalancingSchedules API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,castai}
type RebalancingSchedule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.launchConfiguration)",message="launchConfiguration is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.schedule)",message="schedule is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.triggerConditions)",message="triggerConditions is a required parameter"
	Spec   RebalancingScheduleSpec   `json:"spec"`
	Status RebalancingScheduleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RebalancingScheduleList contains a list of RebalancingSchedules
type RebalancingScheduleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RebalancingSchedule `json:"items"`
}

// Repository type metadata.
var (
	RebalancingSchedule_Kind             = "RebalancingSchedule"
	RebalancingSchedule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RebalancingSchedule_Kind}.String()
	RebalancingSchedule_KindAPIVersion   = RebalancingSchedule_Kind + "." + CRDGroupVersion.String()
	RebalancingSchedule_GroupVersionKind = CRDGroupVersion.WithKind(RebalancingSchedule_Kind)
)

func init() {
	SchemeBuilder.Register(&RebalancingSchedule{}, &RebalancingScheduleList{})
}
