/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AntiAffinityInitParameters struct {

	// affinity should be considered when scaling the workload.
	// If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
	// Defines if anti-affinity should be considered when scaling the workload.
	// If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
	ConsiderAntiAffinity *bool `json:"considerAntiAffinity,omitempty" tf:"consider_anti_affinity,omitempty"`
}

type AntiAffinityObservation struct {

	// affinity should be considered when scaling the workload.
	// If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
	// Defines if anti-affinity should be considered when scaling the workload.
	// If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
	ConsiderAntiAffinity *bool `json:"considerAntiAffinity,omitempty" tf:"consider_anti_affinity,omitempty"`
}

type AntiAffinityParameters struct {

	// affinity should be considered when scaling the workload.
	// If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
	// Defines if anti-affinity should be considered when scaling the workload.
	// If enabled, requiring host ports, or having anti-affinity on hostname will force all recommendations to be deferred.
	// +kubebuilder:validation:Optional
	ConsiderAntiAffinity *bool `json:"considerAntiAffinity,omitempty" tf:"consider_anti_affinity,omitempty"`
}

type CPUInitParameters struct {

	// (Number) The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	ApplyThreshold *float64 `json:"applyThreshold,omitempty" tf:"apply_threshold,omitempty"`

	// i.e. for QUANTILE this should be a [0, 1] float. MAX doesn't accept any args
	// The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// (String) The function used to calculate the resource recommendation. Supported values: QUANTILE, MAX
	// The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
	Function *string `json:"function,omitempty" tf:"function,omitempty"`

	// (Number) The look back period in seconds for the recommendation.
	// The look back period in seconds for the recommendation.
	LookBackPeriodSeconds *float64 `json:"lookBackPeriodSeconds,omitempty" tf:"look_back_period_seconds,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// (Number) Overhead for the recommendation, e.g. 0.1 will result in 10% higher recommendation
	// Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
	Overhead *float64 `json:"overhead,omitempty" tf:"overhead,omitempty"`
}

type CPUObservation struct {

	// (Number) The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	ApplyThreshold *float64 `json:"applyThreshold,omitempty" tf:"apply_threshold,omitempty"`

	// i.e. for QUANTILE this should be a [0, 1] float. MAX doesn't accept any args
	// The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// (String) The function used to calculate the resource recommendation. Supported values: QUANTILE, MAX
	// The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
	Function *string `json:"function,omitempty" tf:"function,omitempty"`

	// (Number) The look back period in seconds for the recommendation.
	// The look back period in seconds for the recommendation.
	LookBackPeriodSeconds *float64 `json:"lookBackPeriodSeconds,omitempty" tf:"look_back_period_seconds,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// (Number) Overhead for the recommendation, e.g. 0.1 will result in 10% higher recommendation
	// Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
	Overhead *float64 `json:"overhead,omitempty" tf:"overhead,omitempty"`
}

type CPUParameters struct {

	// (Number) The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// +kubebuilder:validation:Optional
	ApplyThreshold *float64 `json:"applyThreshold,omitempty" tf:"apply_threshold,omitempty"`

	// i.e. for QUANTILE this should be a [0, 1] float. MAX doesn't accept any args
	// The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
	// +kubebuilder:validation:Optional
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// (String) The function used to calculate the resource recommendation. Supported values: QUANTILE, MAX
	// The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
	// +kubebuilder:validation:Optional
	Function *string `json:"function,omitempty" tf:"function,omitempty"`

	// (Number) The look back period in seconds for the recommendation.
	// The look back period in seconds for the recommendation.
	// +kubebuilder:validation:Optional
	LookBackPeriodSeconds *float64 `json:"lookBackPeriodSeconds,omitempty" tf:"look_back_period_seconds,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// (Number) Overhead for the recommendation, e.g. 0.1 will result in 10% higher recommendation
	// Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
	// +kubebuilder:validation:Optional
	Overhead *float64 `json:"overhead,omitempty" tf:"overhead,omitempty"`
}

type DownscalingInitParameters struct {

	// (String) Recommendation apply type.
	// Defines the apply type to be used when downscaling.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`
}

type DownscalingObservation struct {

	// (String) Recommendation apply type.
	// Defines the apply type to be used when downscaling.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`
}

type DownscalingParameters struct {

	// (String) Recommendation apply type.
	// Defines the apply type to be used when downscaling.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	// +kubebuilder:validation:Optional
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`
}

type MemoryEventInitParameters struct {

	// (String) Recommendation apply type.
	// Defines the apply type to be used when applying recommendation for memory related event.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`
}

type MemoryEventObservation struct {

	// (String) Recommendation apply type.
	// Defines the apply type to be used when applying recommendation for memory related event.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`
}

type MemoryEventParameters struct {

	// (String) Recommendation apply type.
	// Defines the apply type to be used when applying recommendation for memory related event.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	// +kubebuilder:validation:Optional
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`
}

type MemoryInitParameters struct {

	// (Number) The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	ApplyThreshold *float64 `json:"applyThreshold,omitempty" tf:"apply_threshold,omitempty"`

	// i.e. for QUANTILE this should be a [0, 1] float. MAX doesn't accept any args
	// The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// (String) The function used to calculate the resource recommendation. Supported values: QUANTILE, MAX
	// The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
	Function *string `json:"function,omitempty" tf:"function,omitempty"`

	// (Number) The look back period in seconds for the recommendation.
	// The look back period in seconds for the recommendation.
	LookBackPeriodSeconds *float64 `json:"lookBackPeriodSeconds,omitempty" tf:"look_back_period_seconds,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// (Number) Overhead for the recommendation, e.g. 0.1 will result in 10% higher recommendation
	// Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
	Overhead *float64 `json:"overhead,omitempty" tf:"overhead,omitempty"`
}

type MemoryObservation struct {

	// (Number) The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	ApplyThreshold *float64 `json:"applyThreshold,omitempty" tf:"apply_threshold,omitempty"`

	// i.e. for QUANTILE this should be a [0, 1] float. MAX doesn't accept any args
	// The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// (String) The function used to calculate the resource recommendation. Supported values: QUANTILE, MAX
	// The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
	Function *string `json:"function,omitempty" tf:"function,omitempty"`

	// (Number) The look back period in seconds for the recommendation.
	// The look back period in seconds for the recommendation.
	LookBackPeriodSeconds *float64 `json:"lookBackPeriodSeconds,omitempty" tf:"look_back_period_seconds,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// (Number) Overhead for the recommendation, e.g. 0.1 will result in 10% higher recommendation
	// Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
	Overhead *float64 `json:"overhead,omitempty" tf:"overhead,omitempty"`
}

type MemoryParameters struct {

	// (Number) The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// The threshold of when to apply the recommendation. Recommendation will be applied when diff of current requests and new recommendation is greater than set value
	// +kubebuilder:validation:Optional
	ApplyThreshold *float64 `json:"applyThreshold,omitempty" tf:"apply_threshold,omitempty"`

	// i.e. for QUANTILE this should be a [0, 1] float. MAX doesn't accept any args
	// The arguments for the function - i.e. for `QUANTILE` this should be a [0, 1] float. `MAX` doesn't accept any args
	// +kubebuilder:validation:Optional
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// (String) The function used to calculate the resource recommendation. Supported values: QUANTILE, MAX
	// The function used to calculate the resource recommendation. Supported values: `QUANTILE`, `MAX`
	// +kubebuilder:validation:Optional
	Function *string `json:"function,omitempty" tf:"function,omitempty"`

	// (Number) The look back period in seconds for the recommendation.
	// The look back period in seconds for the recommendation.
	// +kubebuilder:validation:Optional
	LookBackPeriodSeconds *float64 `json:"lookBackPeriodSeconds,omitempty" tf:"look_back_period_seconds,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Max values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// this is in MiB, for CPU - this is in cores.
	// Min values for the recommendation, applies to every container. For memory - this is in MiB, for CPU - this is in cores.
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// (Number) Overhead for the recommendation, e.g. 0.1 will result in 10% higher recommendation
	// Overhead for the recommendation, e.g. `0.1` will result in 10% higher recommendation
	// +kubebuilder:validation:Optional
	Overhead *float64 `json:"overhead,omitempty" tf:"overhead,omitempty"`
}

type ScalingPolicyInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	AntiAffinity []AntiAffinityInitParameters `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (String) Recommendation apply type.
	// Recommendation apply type.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	CPU []CPUInitParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// (String) CAST AI cluster id
	// CAST AI cluster id
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Downscaling []DownscalingInitParameters `json:"downscaling,omitempty" tf:"downscaling,omitempty"`

	// (String) Defines possible options for workload management.
	// Defines possible options for workload management.
	// - READ_ONLY - workload watched (metrics collected), but no actions performed by CAST AI.
	// - MANAGED - workload watched (metrics collected), CAST AI may perform actions on the workload.
	ManagementOption *string `json:"managementOption,omitempty" tf:"management_option,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	Memory []MemoryInitParameters `json:"memory,omitempty" tf:"memory,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	MemoryEvent []MemoryEventInitParameters `json:"memoryEvent,omitempty" tf:"memory_event,omitempty"`

	// (String) Scaling policy name
	// Scaling policy name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Startup []StartupInitParameters `json:"startup,omitempty" tf:"startup,omitempty"`
}

type ScalingPolicyObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	AntiAffinity []AntiAffinityObservation `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (String) Recommendation apply type.
	// Recommendation apply type.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	CPU []CPUObservation `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// (String) CAST AI cluster id
	// CAST AI cluster id
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Downscaling []DownscalingObservation `json:"downscaling,omitempty" tf:"downscaling,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Defines possible options for workload management.
	// Defines possible options for workload management.
	// - READ_ONLY - workload watched (metrics collected), but no actions performed by CAST AI.
	// - MANAGED - workload watched (metrics collected), CAST AI may perform actions on the workload.
	ManagementOption *string `json:"managementOption,omitempty" tf:"management_option,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	Memory []MemoryObservation `json:"memory,omitempty" tf:"memory,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	MemoryEvent []MemoryEventObservation `json:"memoryEvent,omitempty" tf:"memory_event,omitempty"`

	// (String) Scaling policy name
	// Scaling policy name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Startup []StartupObservation `json:"startup,omitempty" tf:"startup,omitempty"`
}

type ScalingPolicyParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	AntiAffinity []AntiAffinityParameters `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (String) Recommendation apply type.
	// Recommendation apply type.
	// - IMMEDIATE - pods are restarted immediately when new recommendation is generated.
	// - DEFERRED - pods are not restarted and recommendation values are applied during natural restarts only (new deployment, etc.)
	// +kubebuilder:validation:Optional
	ApplyType *string `json:"applyType,omitempty" tf:"apply_type,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CPU []CPUParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// (String) CAST AI cluster id
	// CAST AI cluster id
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Downscaling []DownscalingParameters `json:"downscaling,omitempty" tf:"downscaling,omitempty"`

	// (String) Defines possible options for workload management.
	// Defines possible options for workload management.
	// - READ_ONLY - workload watched (metrics collected), but no actions performed by CAST AI.
	// - MANAGED - workload watched (metrics collected), CAST AI may perform actions on the workload.
	// +kubebuilder:validation:Optional
	ManagementOption *string `json:"managementOption,omitempty" tf:"management_option,omitempty"`

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Memory []MemoryParameters `json:"memory,omitempty" tf:"memory,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	MemoryEvent []MemoryEventParameters `json:"memoryEvent,omitempty" tf:"memory_event,omitempty"`

	// (String) Scaling policy name
	// Scaling policy name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Startup []StartupParameters `json:"startup,omitempty" tf:"startup,omitempty"`
}

type StartupInitParameters struct {

	// (Number) Defines the duration (in seconds) during which elevated resource usage is expected at startup.
	// When set, recommendations will be adjusted to disregard resource spikes within this period.
	// If not specified, the workload will receive standard recommendations without startup considerations.
	// Defines the duration (in seconds) during which elevated resource usage is expected at startup.
	// When set, recommendations will be adjusted to disregard resource spikes within this period.
	// If not specified, the workload will receive standard recommendations without startup considerations.
	PeriodSeconds *float64 `json:"periodSeconds,omitempty" tf:"period_seconds,omitempty"`
}

type StartupObservation struct {

	// (Number) Defines the duration (in seconds) during which elevated resource usage is expected at startup.
	// When set, recommendations will be adjusted to disregard resource spikes within this period.
	// If not specified, the workload will receive standard recommendations without startup considerations.
	// Defines the duration (in seconds) during which elevated resource usage is expected at startup.
	// When set, recommendations will be adjusted to disregard resource spikes within this period.
	// If not specified, the workload will receive standard recommendations without startup considerations.
	PeriodSeconds *float64 `json:"periodSeconds,omitempty" tf:"period_seconds,omitempty"`
}

type StartupParameters struct {

	// (Number) Defines the duration (in seconds) during which elevated resource usage is expected at startup.
	// When set, recommendations will be adjusted to disregard resource spikes within this period.
	// If not specified, the workload will receive standard recommendations without startup considerations.
	// Defines the duration (in seconds) during which elevated resource usage is expected at startup.
	// When set, recommendations will be adjusted to disregard resource spikes within this period.
	// If not specified, the workload will receive standard recommendations without startup considerations.
	// +kubebuilder:validation:Optional
	PeriodSeconds *float64 `json:"periodSeconds,omitempty" tf:"period_seconds,omitempty"`
}

// ScalingPolicySpec defines the desired state of ScalingPolicy
type ScalingPolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ScalingPolicyParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ScalingPolicyInitParameters `json:"initProvider,omitempty"`
}

// ScalingPolicyStatus defines the observed state of ScalingPolicy.
type ScalingPolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ScalingPolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ScalingPolicy is the Schema for the ScalingPolicys API. Manage workload scaling policy. Scaling policy reference https://docs.cast.ai/docs/woop-scaling-policies
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,castai}
type ScalingPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.applyType) || (has(self.initProvider) && has(self.initProvider.applyType))",message="spec.forProvider.applyType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterId) || (has(self.initProvider) && has(self.initProvider.clusterId))",message="spec.forProvider.clusterId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.cpu) || (has(self.initProvider) && has(self.initProvider.cpu))",message="spec.forProvider.cpu is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.managementOption) || (has(self.initProvider) && has(self.initProvider.managementOption))",message="spec.forProvider.managementOption is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.memory) || (has(self.initProvider) && has(self.initProvider.memory))",message="spec.forProvider.memory is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ScalingPolicySpec   `json:"spec"`
	Status ScalingPolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ScalingPolicyList contains a list of ScalingPolicys
type ScalingPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ScalingPolicy `json:"items"`
}

// Repository type metadata.
var (
	ScalingPolicy_Kind             = "ScalingPolicy"
	ScalingPolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ScalingPolicy_Kind}.String()
	ScalingPolicy_KindAPIVersion   = ScalingPolicy_Kind + "." + CRDGroupVersion.String()
	ScalingPolicy_GroupVersionKind = CRDGroupVersion.WithKind(ScalingPolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&ScalingPolicy{}, &ScalingPolicyList{})
}
